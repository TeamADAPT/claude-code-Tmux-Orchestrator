#!/bin/bash
# Self-Healing Hook Monitor
# Prevents runaway hooks and automatically repairs hook failures

TIMESTAMP=$(date -u +%Y%m%d_%H%M%S)
CURRENT_WINDOW=$(tmux display-message -p "#{session_name}:#{window_index}" 2>/dev/null || echo "standalone")

# Health check configuration
HEALTH_KEY="hook:health:$CURRENT_WINDOW"
MAX_RAPID_EXECUTIONS=10
RAPID_WINDOW=60  # seconds
EMERGENCY_COOLDOWN=300  # 5 minutes

# Track hook execution
redis-cli -p 18000 zadd "hook:execution:log" $(date +%s) "$TIMESTAMP:$0" >/dev/null
redis-cli -p 18000 zremrangebyscore "hook:execution:log" -inf $(( $(date +%s) - RAPID_WINDOW )) >/dev/null

# Count recent executions of this hook
execution_count=$(redis-cli -p 18000 zcount "hook:execution:log" $(( $(date +%s) - RAPID_WINDOW )) +inf)

if [ "$execution_count" -gt "$MAX_RAPID_EXECUTIONS" ]; then
    echo "🚨 HOOK HEALTH ALERT: Rapid execution detected ($execution_count in ${RAPID_WINDOW}s)" >&2
    
    # Emergency shutdown of problematic hooks
    redis-cli -p 18000 set "hook:emergency:shutdown" 1 EX $EMERGENCY_COOLDOWN >/dev/null
    
    # Log the emergency
    redis-cli -p 18000 xadd "nova.hook.emergencies" '*' \
        timestamp "$TIMESTAMP" \
        window "$CURRENT_WINDOW" \
        hook_name "$(basename $0)" \
        execution_count "$execution_count" \
        action "emergency_shutdown" >/dev/null
    
    # Activate Really Chill Willy if available
    if [ -f "/nfs/projects/claude-code-Tmux-Orchestrator/.claude/hooks/really_chill_willy.sh" ]; then
        echo "🐧 Activating Really Chill Willy for emergency cooldown" >&2
        bash /nfs/projects/claude-code-Tmux-Orchestrator/.claude/hooks/really_chill_willy.sh
    fi
    
    echo "🛑 Hook entering emergency cooldown for ${EMERGENCY_COOLDOWN}s" >&2
    exit 0
fi

# Check for emergency shutdown
if redis-cli -p 18000 get "hook:emergency:shutdown" | grep -q 1; then
    echo "🛑 Hook emergency shutdown active - system cooling down" >&2
    exit 0
fi

# Health monitoring checks
hook_health_status() {
    local issues=0
    
    # Check for infinite loop indicators
    if pgrep -f "exec.*$0" >/dev/null; then
        echo "⚠️ WARNING: Detected exec self-restart pattern" >&2
        issues=$((issues + 1))
    fi
    
    # Check for API hammering patterns
    if pgrep -f "claude.*code.*-p" >/dev/null; then
        echo "⚠️ WARNING: Detected claude code -p in hook process" >&2
        issues=$((issues + 1))
    fi
    
    # Check Redis connection health
    if ! redis-cli -p 18000 ping >/dev/null 2>&1; then
        echo "⚠️ WARNING: Redis connection failed" >&2
        issues=$((issues + 1))
    fi
    
    return $issues
}

# Run health checks
if ! hook_health_status; then
    echo "🔧 Hook health issues detected - initiating self-repair" >&2
    
    # Log health issue
    redis-cli -p 18000 xadd "nova.hook.health" '*' \
        timestamp "$TIMESTAMP" \
        window "$CURRENT_WINDOW" \
        hook_name "$(basename $0)" \
        status "health_issues_detected" \
        action "self_repair_initiated" >/dev/null
    
    # Attempt self-repair by creating safe backup hook
    cat > "/tmp/safe_hook_backup_$TIMESTAMP.sh" << 'EOF'
#!/bin/bash
# Emergency safe hook - generated by self-healing system
echo "🔧 Emergency safe hook activated" >&2
echo "Original hook had health issues - using minimal safe operation" >&2

# Only log to work queue, no API calls, no self-restart
echo "EMERGENCY_SAFE_MODE: $(date -u +%Y%m%d_%H%M%S)" >> /tmp/torch_work_queue.txt

# Exit safely
exit 2
EOF
    
    chmod +x "/tmp/safe_hook_backup_$TIMESTAMP.sh"
    echo "🛟 Created emergency safe hook backup" >&2
fi

# Update health status
redis-cli -p 18000 set "$HEALTH_KEY" "healthy" EX 120 >/dev/null

# Store health metrics
redis-cli -p 18000 xadd "nova.hook.metrics" '*' \
    timestamp "$TIMESTAMP" \
    window "$CURRENT_WINDOW" \
    hook_name "$(basename $0)" \
    execution_count "$execution_count" \
    health_status "healthy" \
    monitoring_active "true" >/dev/null

echo "💚 Hook health monitor: System healthy" >&2
exit 0